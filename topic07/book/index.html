 <!DOCTYPE html>
 <html>
   <head>
     <meta charset="utf-8" />
     <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
   
     <title> Lab-07 </title>
   
     <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
     <link rel="stylesheet" href="./style/semantic/css/semantic.min.css" type="text/css">  
     <link rel="stylesheet" href="./style/custom/main.css" type="text/css"> 
   
     <script src="./style/custom/jquery-2.1.0.min.js"></script> 
     <script src="./style/custom/jquery.address-1.6.min.js"></script>
     <script src="./style/semantic/javascript/semantic.min.js"></script>
   
     <link rel="stylesheet" href="./style/highlight/school_book.css">
     <script src="./style/highlight/highlight.pack.js"></script> 
     <script>hljs.initHighlightingOnLoad();</script>
   
     <script src="./style/custom/common.js"> </script> 
     <script src="./style/custom/main.js"> </script> 
  </head>
  <body>
  <nav class="ui fixed top pointing borderless inverted menu">
    <header class="header item"> <a href="../index.html">UML
</a></header>
    <div class="right tab-menu menu">
          <a class="item" data-tab="Lab-07"> Lab-07 </a>
          <a class="item" data-tab="01"> 01 </a>
          <a class="item" data-tab="02"> 02 </a>
          <a class="item" data-tab="03"> 03 </a>
          <a class="item" data-tab="04"> 04 </a>
          <a class="item" data-tab="05"> 05 </a>
          <a class="item" data-tab="06"> 06 </a>
          <a class="item" data-tab="07"> 07 </a>
          <a class="item" data-tab="Exercises"> Exercises </a>
    </div>
  </nav>

  <br>

	  <section data-tab="Lab-07" class="ui tab stacked moodle-book segment">
	     <h1>Objectives</h1>
<ul>
<li>Introduce UML Class Diagram modeling using Visual Paradigm</li>
<li>Define a simple model and implement it in Play</li>
<li>Write comprehensive unit tests to exercise the model</li>
</ul>
	  </section>
	  <section data-tab="01" class="ui tab stacked moodle-book segment">
	     <h1>JPA Model Project</h1>
<p>Start by creating a brand new Play project. Do this by determining the parent folder (most likely your workspace) and running a command prompt. Then type:</p>
<pre><code>play new jpamodel
</code></pre>

<p>Once this has completed, change into the folder just created (jpamodel) and run the eclipsify command:</p>
<pre><code>cd jpamodel
play eclipsify
</code></pre>

<p>You can now import the project into eclipse in the usual way.</p>
<p>We will make one small change to the default 'conf/dependencies.yml':</p>
<pre><code># Application dependencies

require:
    - play
    - play -&gt; cloudbees 0.2.2     
</code></pre>

<p>For this to take effect you will need to do two commands again:</p>
<pre><code>play deps
play eclipsify
</code></pre>

<p>Back in eclipse, refresh (File-&gt;Refresh) the project.</p>
<p>Finally, in conf/application.conf, uncomment the following line:</p>
<pre><code>db=mem
</code></pre>
	  </section>
	  <section data-tab="02" class="ui tab stacked moodle-book segment">
	     <h1>Visual Paradigm</h1>
<p>For this step to work you will need to have installed Visual Paradigm. This is the particular product here:</p>
<ul>
<li><a href="http://www.visual-paradigm.com/product/?favor=vpuml">http://www.visual-paradigm.com/product/?favor=vpuml</a></li>
</ul>
<p>... and it can be downloaded here</p>
<ul>
<li><a href="http://www.visual-paradigm.com/download/vpuml.jsp">http://www.visual-paradigm.com/download/vpuml.jsp</a></li>
</ul>
<p>If you select the 'no install' version, then it can be reliably run from a memory stick in the IT labs.</p>
<p>You will require this Key in order to activate the application:</p>
<p>Key for Visual Paradigm 11: Standard Edition:  0633Z-TIOXM-H8GL2-TGRY2-J83CD</p>
<p>The pc will need to be online when it app launches in order to validate.</p>
<p>Launch Visual Paradigm now, and select File-&gt;Create New Project:</p>
<p><img alt="" src="img/01.png"></p>
<p>This should present a screen like this:</p>
<p><img alt="" src="img/02.png"></p>
<hr>
<p>We start by creating a new "Class Diagram":</p>
<hr>
<p><img alt="" src="img/03.png"></p>
<p>Press OK and the class diagram editor is displayed:</p>
<hr>
<p>Before we create any classes, we are going to make some small adjustments to the default look and feel. Select 'Tools-&gt;Projects Options-&gt;Diagramming-&gt;Shape' and make the 'default shape fill format'  white (instead of blue currently):</p>
<hr>
<p><img alt="" src="img/07.png"></p>
<hr>
<p>Then select 'Class-&gt;Presentation' and set 'show attribute option' and 'show operation option' to both be 'hide all'</p>
<h2><img alt="" src="img/08.png"></h2>
<p>Drag the 'class' icon onto the canvas, call the class Club. Create another one and call it Player. Your canvas should look like this:</p>
<hr>
<h2><img alt="" src="img/09.png"></h2>
<p>Save the project. Make sure you remember where you put it. A useful place is to put in inside the same folder as the play project</p>
	  </section>
	  <section data-tab="03" class="ui tab stacked moodle-book segment">
	     <h1>Initial Model for Player and Club</h1>
<p>In your jpamodel eclipse project, create two new classes in the model package:</p>
<h2>Club</h2>
<pre><code class="java">package models;

import javax.persistence.Entity;
import play.db.jpa.Model;

@Entity
public class Club extends Model
{
  public String name;

  public Club(String name)
  {
    this.name = name;
  }
}
</code></pre>

<h2>Player</h2>
<pre><code class="java">package models;

import javax.persistence.Entity;
import play.db.jpa.Model;

@Entity
public class Player extends Model
{
  public String name;

  public Player(String name)
  {
    this.name = name;
  }
}
</code></pre>

<p>Now we create the unit test harnesses. In 'test/default package' create these two tests:</p>
<h2>ClubTest</h2>
<pre><code class="java">import org.junit.*;

import java.util.*;
import play.test.*;
import models.*;

public class ClubTest extends UnitTest 
{
  @Before
  public void setup()
  {
  }

  @After
  public void teardown()
  {
  }

  @Test
  public void testCreate()
  {

  }
}
</code></pre>

<h2>PlayerTest</h2>
<pre><code class="java">import org.junit.*;

import java.util.*;
import play.test.*;
import models.*;

public class PlayerTest extends UnitTest 
{
  @Before
  public void setup()
  {
  }

  @After
  public void teardown()
  {
  }

  @Test
  public void testCreate()
  {

  }
}
</code></pre>

<p>Run the app now in 'test' mode:</p>
<pre><code>play test
</code></pre>

<p>...and navigate to the test runner page:</p>
<ul>
<li><a href="http://localhost:9000/@tests">http://localhost:9000/@tests</a></li>
</ul>
<p>Select the Club and Player tests - and they should be green.</p>
<p>Also try the database interface:</p>
<ul>
<li><a href="http://localhost:9000/@db">http://localhost:9000/@db</a></li>
</ul>
	  </section>
	  <section data-tab="04" class="ui tab stacked moodle-book segment">
	     <h1>Initial Tests for Player and Club</h1>
<h2>PlayerTest</h2>
<p>In PlayerTest introduce a fixture and create some test objects:</p>
<pre><code class="java">public class PlayerTest extends UnitTest 
{
  private Player p1, p2, p3;

  @Before
  public void setup()
  {
    p1 = new Player(&quot;mike&quot;);
    p2 = new Player(&quot;jim&quot;);
    p3 = new Player(&quot;frank&quot;);
    p1.save();
    p2.save();
    p3.save();
  }

  @After
  public void teardown()
  {
    p1.delete();
    p2.delete();
    p3.delete();
  }

  @Test
  public void testCreate()
  { 
  }
}
</code></pre>

<p>Run the tests - and have a look at the admin interface. Can you see any player objects? No because teardown() is deleteing all of the objects. Comment out the @After annotation:</p>
<pre><code class="java"> //@After
</code></pre>

<p>and run the tests again. This time - if you refresh the admin page - you will see the three player objects. </p>
<p>Into the player class, introduce the following method (at the end):</p>
<pre><code class="java">  public String toString()
  {
    return name;
  }
</code></pre>

<p>Save and run the tests again. Do you see any difference? You should now see the actual name of the player in the list, as opposed to just 'Player[x]' where x is the id. Now uncomment the @After annotation, but remember you can comment it in/out occasionally if you want to inspect the objects. Being able to see them in the admin interface can be particularly useful if you are introducing new relationships between objects.</p>
<p>Now we will bring in  utility function into the Player class:</p>
<pre><code class="java">  public static Player findByName(String name)
  {
    return find(&quot;name&quot;, name).first();
  }
</code></pre>

<p>Note this method is 'static'.</p>
<p>Now we can actually implement a test. </p>
<pre><code class="java">  @Test
  public void testCreate()
  {
    Player a = Player.findByName(&quot;mike&quot;);
    assertNotNull(a);
    assertEquals(&quot;mike&quot;, a.name);
    Player b = Player.findByName(&quot;jim&quot;);
    assertNotNull(b);
    assertEquals(&quot;jim&quot;, b.name);
    Player c = Player.findByName(&quot;frank&quot;);
    assertNotNull(c);
    assertEquals(&quot;frank&quot;, c.name);
  }
</code></pre>

<p>This test should pass. Change one of the stings to deliberately force an error just to be sure.</p>
<p>Do one more (negative) test to make sure that if we try to find an object that is not there, we get null:</p>
<pre><code class="java">  @Test
  public void testNotThere()
  {
    Player a = Player.findByName(&quot;george&quot;);
    assertNull(a);
  }
</code></pre>

<p>All tests should pass now.</p>
<h2>ClubTest</h2>
<p>Extend Club with the same utility methods as Player:</p>
<pre><code class="java">  public String toString()
  {
    return name;
  }

  public static Club findByName(String name)
  {
    return find(&quot;name&quot;, name).first();
  }  
</code></pre>

<p>and now we can write a similar set of tests in PlayerTest:</p>
<pre><code class="java">import org.junit.*;

import java.util.*;
import play.test.*;
import models.*;

public class ClubTest extends UnitTest 
{
  private Club c1, c2, c3;

  @Before
  public void setup()
  {
    c1 = new Club(&quot;tramore&quot;);
    c2 = new Club(&quot;dunmore&quot;);
    c3 = new Club(&quot;fenor&quot;);
    c1.save();
    c2.save();
    c3.save();
  }

  @After
  public void teardown()
  {
    c1.delete();
    c2.delete();
    c3.delete();
  }

  @Test
  public void testCreate()
  {
    Club a = Club.findByName(&quot;tramore&quot;);
    assertNotNull(a);
    assertEquals(&quot;tramore&quot;, a.name);
    Club b = Club.findByName(&quot;dunmore&quot;);
    assertNotNull(b);
    assertEquals(&quot;dunmore&quot;, b.name);
    Club c = Club.findByName(&quot;fenor&quot;);
    assertNotNull(c);
    assertEquals(&quot;fenor&quot;, c.name);
  }

  @Test
  public void testNotThere()
  {
    Club a = Club.findByName(&quot;george&quot;);
    assertNull(a);
  }
}
</code></pre>

<p>These tests should run successfully. Experiment with commentin out the @After annotation and seeing the actual objects in the admin interface.</p>
	  </section>
	  <section data-tab="05" class="ui tab stacked moodle-book segment">
	     <h1>Modeling a Player / Club Relationship</h1>
<p>Returning to Visual Paradigm - you may notice a red line under each class. It says 'Very bad' if you click on it. Do so now, and in a subsequent dialog you will have an opportunity to disable this 'Quality Checker' completely We will not be using this feature.</p>
<p>On the pallette on the left, select the 'association' element and use it to connect Club and Player. It should look like this:</p>
<p><img alt="" src="img/10.png"></p>
<p>Select the association (the line), and locate the following panel (which should look like this:</p>
<p><img alt="" src="img/11.png"></p>
<p>Now edit as follows:</p>
<p>For Role A:</p>
<p><img alt="" src="img/12.png"></p>
<p>For Role B:</p>
<p><img alt="" src="img/13.png"></p>
<p>If this works, then the class diagram should look like this:</p>
<p><img alt="" src="img/14.png"></p>
<p>We can now implement this relationship. In Eclipse, modify Club as follows:</p>
<pre><code class="java">public class Club extends Model
{
  //... 
  @OneToMany(cascade=CascadeType.ALL)
  public List&lt;Player&gt; players;

  public Club(String name)
  {
    this.name = name;
    this.players = new ArrayList&lt;Player&gt;();
  }
  //...
  public void addPlayer(Player player)
  {
    players.add(player);
  }
  //...
}
</code></pre>

<p>This establishes the relationship as modeled in UML.</p>
	  </section>
	  <section data-tab="06" class="ui tab stacked moodle-book segment">
	     <h1>Testing a Player / Club Relationship</h1>
<p>We will focus these tests in the ClubTest class. Expand the fixture:</p>
<pre><code class="java">  private Player p1, p2, p3;
</code></pre>

<p>and in the setup(), create some players and add some of them (not all)  to the 'c1' club:</p>
<pre><code class="java">  @Before
  public void setup()
  {
    p1 = new Player(&quot;mike&quot;);
    p2 = new Player(&quot;jim&quot;);
    p3 = new Player(&quot;frank&quot;);
    c1 = new Club(&quot;tramore&quot;);
    c2 = new Club(&quot;dunmore&quot;);
    c3 = new Club(&quot;fenor&quot;);

    c1.addPlayer(p1);
    c1.addPlayer(p2);

    c1.save();
    c2.save();
    c3.save();
  }
</code></pre>

<p>We can now write a new test to see if the 'tramore' has the players "mike" and "jim":</p>
<pre><code class="java">  @Test
  public void testPlayers()
  {
    Club tramore = Club.findByName(&quot;tramore&quot;);

    assertEquals (2, tramore.players.size());

    Player mike  = Player.findByName(&quot;mike&quot;);
    Player jim   = Player.findByName(&quot;jim&quot;);
    Player frank = Player.findByName(&quot;framk&quot;);

    assertTrue  (tramore.players.contains(mike));
    assertTrue  (tramore.players.contains(jim));
    assertFalse (tramore.players.contains(frank));
  }  
</code></pre>

<p>This test should pass.</p>
<p>We might be interested in seeing how the database models the relationship. Comment out the @After annotation, and also all of the @Test annotations except one (the last one). Run the test, and then explore the Player objects in the @db interface. See if you can make sense of them. You may wish to do this occasionally, but be sure to comment in all the annotations, and perhaps also restart the application as leaving these annotations out will cause serious anomalies in the database.</p>
<p>Now introduce the following test:</p>
<pre><code class="java">  @Test
  public void testRemovePlayer()
  {
    Club tramore = Club.findByName(&quot;tramore&quot;);
    assertEquals(2, tramore.players.size());

    Player mike  = Player.findByName(&quot;mike&quot;);
    assertTrue(tramore.players.contains(mike));
    tramore.players.remove(mike);
    tramore.save();

    Club c = Club.findByName(&quot;tramore&quot;);
    assertEquals(1, c.players.size());

    mike.delete();
  }
</code></pre>

<p>Read and absorb the logic of this test. As an experiment, comment out the final line (deleting mike). Then look to the @db interface and note that mike is still in the database after the test have run. </p>
<p>Note also that if we leave the deletion of mike commented out, and re-run the tests - then other tests start to fail. The only cure now will be to restart the application.</p>
	  </section>
	  <section data-tab="07" class="ui tab stacked moodle-book segment">
	     <h1>Bidirectional Club / Player Relationship</h1>
<p>We might like each player to also 'know' which club he/she belongs to. In fact his is probably a more natural relationship for these model elements.</p>
<p>In Visual Paradigm, select the association between Club and Player again, its properties may look like this:</p>
<p><img alt="" src="img/15.png"></p>
<p>Adjust Role A (the role at the Club end) by giving it a name, changing its navigability and multiplicity paramaters as shown here:</p>
<p><img alt="" src="img/16.png"></p>
<p>The class diagram will now look like this:</p>
<p><img alt="" src="img/17.png"></p>
<p>Contrast this with the earlier version:</p>
<p><img alt="" src="img/14.png"></p>
<p>Implementing this variant of the relationship requires additional attributes and annotations in both Player and Club.</p>
<h2>Player:</h2>
<pre><code class="java">  @ManyToOne
  public Club club;
</code></pre>

<h2>Club</h2>
<pre><code>  @OneToMany(mappedBy=&quot;club&quot;, cascade=CascadeType.ALL)
  public List&lt;Player&gt; players;
</code></pre>

<p>The name 'club' must match in both the annotation and the attribute. We also need to make the following adjustment to the Club.addPlayer method:</p>
<pre><code class="java">  public void addPlayer(Player player)
  {
    player.club = this;
    players.add(player);
  }
</code></pre>

<p>This method ensures that the relationship is correctly established.</p>
<p>No adjustment to the model can be considered complete without a unit test. Introduce the following test to ClubTest:</p>
<pre><code class="java">  @Test
  public void testPlayerClub()
  {
    Player mike  = Player.findByName(&quot;mike&quot;);
    assertNotNull (mike.club);
    assertEquals (&quot;tramore&quot;, mike.club.name);
  }
</code></pre>
	  </section>
	  <section data-tab="Exercises" class="ui tab stacked moodle-book segment">
	     <h1>Exercises</h1>
<p>This is an extension of the model to include:</p>
<ul>
<li>Divisions</li>
<li>Sponsors</li>
</ul>
<p><img alt="" src="img/18.png"></p>
<p>You should be able to: </p>
<ul>
<li>Replicate this model in Visual Paradigm. </li>
<li>Incorporate the new classes into the jpamodel project</li>
<li>Build some unit tests to exercises the model</li>
</ul>
	  </section>
  <div class="ui fixed bottom borderless menu">'
    <div class="ui small item"> 
    <p id="footertext">
    Prepared by  Eamonn de Leastar (edeleastar@wit.ie). Except where otherwise noted, this content is licensed under a  
     <a  href="http://creativecommons.org/licenses/by-nc/4.0/" title="External link to http://creativecommons.org/licenses/by-nc/4.0/" 
       target="_blank">Creative Commons Attribution-NonCommercial 4.0 License
     </a>
     </p>
    </div>
  </div>   
    
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-49703418-4']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>  </body>
 </html>